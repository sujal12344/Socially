generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  // Mendetry fields
  id       String @id @default(cuid())
  email    String @unique
  username String @unique
  clerkId  String @unique

  // Optional fields
  name     String?
  bio      String?
  image    String?
  location String?
  website  String?

  //timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations: 
  // One-to-many relation
  posts    Post[] // One-to-many
  comments Comment[] // One-to-many
  likes    Like[] // One-to-many

  // Below are many-to-many relations
  followers Follows[] @relation(name: "follower") // one-to-many relation. A user can have many followers
  following Follows[] @relation(name: "following") // one-to-many relation. A user can follow many users

  // Below are many-to-many relations
  Notification         Notification[] @relation("userNotifications") //one-to-many relation. notifications received by a user
  notificationsCreated Notification[] @relation("notificationCreator") // one-to-many relation. notifications created/generated by a user

  meessagesSent     Message[] @relation("sender") // one-to-many relation. A user can send many messages
  meessagesReceived Message[] @relation("receiver") // one-to-many relation. A user can receive many messages

  // Model level attributes/constraints
}

model Message {
  // Mendetry fields
  id             String  @id @unique @default(cuid())
  senderUserId   String
  receiverUserId String
  content        String
  read           Boolean @default(false)

  // Relations
  sender   User @relation("sender", fields: [senderUserId], references: [id], onDelete: Cascade, onUpdate: Cascade) // One-to-many relation. A user can send many messages
  receiver User @relation("receiver", fields: [receiverUserId], references: [id], onDelete: Cascade, onUpdate: Cascade) // One-to-many relation. A user can receive many messages

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Model level attributes/constraints
  @@index([senderUserId, receiverUserId]) // composite index for faster queries
}

model Post {
  // Mendetry fields
  id       String @id @default(cuid())
  authorId String

  // Optional fields
  content String?
  image   String?

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  // One-to-one relation
  author User @relation(fields: [authorId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  // cascade delete/update means delete/update all posts if author is deleted/updated 
  // One-to-one relation. A post can have only one author

  // One-to-many relation
  comments     Comment[] // One-to-many relation. A post can have many comments
  likes        Like[] // One-to-many relation. A post can have many likes
  Notification Notification[] // One-to-many relation. A post can have many notifications
}

model Comment {
  // Mendetry fields
  id       String @id @default(cuid())
  content  String
  authorId String
  postId   String

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  // One-to-one relation
  author User @relation(fields: [authorId], references: [id], onDelete: Cascade, onUpdate: Cascade) // One-to-one relation. A comment can have only one author
  post   Post @relation(fields: [postId], references: [id], onDelete: Cascade, onUpdate: Cascade) // One-to-one relation. A comment can have only one post

  Notification Notification[] // One-to-many relation. A comment can have many notifications

  // Model level attributes/constraints
  @@index([authorId, postId]) // composite index for faster queries
}

model Like {
  // Mendetry fields
  id     String @id @default(cuid())
  postId String
  userId String

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  // One-to-one relation
  user User @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade) // One-to-one relation. A like can have only one user
  post Post @relation(fields: [postId], references: [id], onDelete: Cascade, onUpdate: Cascade) // One-to-one relation. A like can have only one post

  // Model level attributes/constraints
  @@unique([userId, postId]) // this prevents same user liking post twice
  @@index([userId, postId]) // composite index for faster queries
}

model Follows {
  // Mendetry fields
  followerId  String
  followingId String

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  // One-to-one relation
  follower  User @relation(name: "follower", fields: [followerId], references: [id], onDelete: Cascade, onUpdate: Cascade) // One-to-many relation. A user can have many followers
  following User @relation(name: "following", fields: [followingId], references: [id], onDelete: Cascade, onUpdate: Cascade) // One-to-many relation. A user can follow many users

  // Model level attributes/constraints
  @@id([followerId, followingId]) // Composite primary key. This means that the combination of followerId and followingId must be unique
  @@index([followerId, followingId]) // Index for faster lookups. This is optional but can improve performance for large datasets
}

model Notification {
  // Mendetry fields
  id        String           @id @default(cuid())
  userId    String
  creatorId String
  type      NotificationType
  read      Boolean          @default(false)

  // Optional fields
  postId    String?
  commentId String?

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  // One-to-many relation
  user    User @relation("userNotifications", fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade) // One-to-many relation. A user can have many notifications
  creator User @relation("notificationCreator", fields: [creatorId], references: [id], onDelete: Cascade, onUpdate: Cascade) // One-to-many relation. A user can create many notifications

  // One-to-one relation
  post    Post?    @relation(fields: [postId], references: [id], onDelete: Cascade, onUpdate: Cascade) // One-to-one relation. A notification can be related to one post
  comment Comment? @relation(fields: [commentId], references: [id], onDelete: Cascade, onUpdate: Cascade) // One-to-one relation. A notification can be related to one comment

  // Model level attributes/constraints
  @@index([userId, createdAt])
}

enum NotificationType {
  LIKE
  COMMENT
  FOLLOW
  MESSAGE
}
